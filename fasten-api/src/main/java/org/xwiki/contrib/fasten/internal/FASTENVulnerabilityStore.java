/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 */
package org.xwiki.contrib.fasten.internal;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import javax.inject.Inject;
import javax.inject.Singleton;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.collections4.MapUtils;
import org.apache.solr.client.solrj.SolrClient;
import org.apache.solr.client.solrj.SolrQuery;
import org.apache.solr.client.solrj.SolrServerException;
import org.apache.solr.client.solrj.request.schema.SchemaRequest;
import org.apache.solr.client.solrj.response.QueryResponse;
import org.apache.solr.common.SolrDocument;
import org.apache.solr.common.SolrDocumentList;
import org.apache.solr.common.SolrInputDocument;
import org.apache.solr.schema.FieldType;
import org.xwiki.component.annotation.Component;
import org.xwiki.component.phase.Initializable;
import org.xwiki.component.phase.InitializationException;
import org.xwiki.contrib.fasten.FASTENExtension;
import org.xwiki.contrib.fasten.FASTENExtensionQuery;
import org.xwiki.contrib.fasten.FASTENVulnerability;
import org.xwiki.extension.Extension;
import org.xwiki.extension.ExtensionId;
import org.xwiki.extension.index.internal.ExtensionIndexStore;
import org.xwiki.extension.internal.converter.ExtensionIdConverter;
import org.xwiki.extension.repository.InstalledExtensionRepository;
import org.xwiki.extension.repository.result.CollectionIterableResult;
import org.xwiki.extension.repository.result.IterableResult;
import org.xwiki.extension.repository.search.SearchException;
import org.xwiki.search.solr.Solr;
import org.xwiki.search.solr.SolrException;
import org.xwiki.search.solr.SolrUtils;
import org.xwiki.search.solr.internal.DefaultSolrUtils;

/**
 * Helper to manipulate the storage of vulnerabilities.
 * 
 * @version $Id$
 */
@Component(roles = FASTENVulnerabilityStore.class)
@Singleton
public class FASTENVulnerabilityStore implements Initializable
{
    /**
     * The prefix used for all the fields containing vulnerability metadata.
     */
    public static final String SOLR_FIELD_VULNERAVILITY_PREFIX = "fasten_vulnerability_";

    /**
     * The list of vulnerability ids affecting the extension.
     */
    public static final String SOLR_FIELD_VULNERAVILITY_IDS = SOLR_FIELD_VULNERAVILITY_PREFIX + "ids";

    /**
     * The suffix used for the field containing the description of a vulnerability.
     */
    public static final String SOLR_FIELD_VULNERAVILITY_DESCRIPTION_SUFFIX =
        String.format("__%sdescription", SOLR_FIELD_VULNERAVILITY_PREFIX);

    /**
     * The suffix used for the field containing the severity of a vulnerability.
     */
    public static final String SOLR_FIELD_VULNERAVILITY_SEVERITY_SUFFIX =
        String.format("__%sseverity", SOLR_FIELD_VULNERAVILITY_PREFIX);

    private static final String SOLR_TOOL_NAME = "name";

    private static final String SOLR_TOOL_WILDCARD = "*";

    @Inject
    private Solr solr;

    @Inject
    private SolrUtils solrUtils;

    @Inject
    // TODO: expose publicly what's needed to avoid using internal components
    private ExtensionIndexStore store;

    @Inject
    private InstalledExtensionRepository installedExtension;

    private SolrClient extensionIndexClient;

    @Override
    public void initialize() throws InitializationException
    {
        try {
            this.extensionIndexClient = this.solr.getClient("extension_index");
        } catch (SolrException e) {
            throw new InitializationException("Failed to get the Solr search core client", e);
        }

        // Make sure the schema contain the required fields
        try {
            boolean update = setStringField(SOLR_FIELD_VULNERAVILITY_IDS, true, false);
            update |= setStringField(getDescriptionFieldName(SOLR_TOOL_WILDCARD), false, true);
            update |= setStringField(getSeverityFieldName(SOLR_TOOL_WILDCARD), false, true);

            if (update) {
                this.extensionIndexClient.commit();
            }
        } catch (Exception e) {
            throw new InitializationException("Failed to initialize the index", e);
        }
    }

    private String getDescriptionFieldName(String id)
    {
        return id + SOLR_FIELD_VULNERAVILITY_DESCRIPTION_SUFFIX;
    }

    private String getSeverityFieldName(String id)
    {
        return id + SOLR_FIELD_VULNERAVILITY_SEVERITY_SUFFIX;
    }

    private boolean exist(String name, boolean dynamic)
    {
        try {
            if (dynamic) {
                new SchemaRequest.DynamicField(name).process(this.extensionIndexClient);
            } else {
                new SchemaRequest.Field(name).process(this.extensionIndexClient);
            }
        } catch (Exception e) {
            return false;
        }

        return true;
    }

    private boolean setStringField(String name, boolean multiValued, boolean dynamic, Object... attributes)
        throws SolrServerException, IOException
    {
        return setField(name, multiValued ? DefaultSolrUtils.SOLR_TYPE_STRINGS : DefaultSolrUtils.SOLR_TYPE_STRING,
            dynamic, attributes);
    }

    private boolean setField(String name, String type, boolean dynamic, Object... attributes)
        throws SolrServerException, IOException
    {
        Map<String, Object> fieldAttributes = new HashMap<>();
        fieldAttributes.put(SOLR_TOOL_NAME, name);
        fieldAttributes.put(FieldType.TYPE, type);

        MapUtils.putAll(fieldAttributes, attributes);

        return setField(fieldAttributes, dynamic);
    }

    private boolean setField(Map<String, Object> fieldAttributes, boolean dynamic)
        throws SolrServerException, IOException
    {
        String name = (String) fieldAttributes.get(SOLR_TOOL_NAME);

        if (!exist(name, dynamic)) {
            if (dynamic) {
                new SchemaRequest.AddDynamicField(fieldAttributes).process(this.extensionIndexClient);
            } else {
                new SchemaRequest.AddField(fieldAttributes).process(this.extensionIndexClient);
            }

            return true;
        }

        return false;
    }

    /**
     * @param extensionId the id of the extension
     * @param vulnerabilities the vulnerabilities to associate with the extension
     * @throws SolrServerException
     * @throws IOException
     */
    public void update(ExtensionId extensionId, List<FASTENVulnerability> vulnerabilities)
        throws SolrServerException, IOException
    {
        if (CollectionUtils.isEmpty(vulnerabilities)) {
            return;
        }

        SolrInputDocument solrDocument = new SolrInputDocument();

        this.solrUtils.set("id", ExtensionIdConverter.toString(extensionId), solrDocument);

        List<String> ids = new ArrayList<>(vulnerabilities.size());
        for (FASTENVulnerability vulnerability : vulnerabilities) {
            ids.add(vulnerability.getId());

            // Description
            this.solrUtils.setAtomic(SolrUtils.ATOMIC_UPDATE_MODIFIER_SET,
                getDescriptionFieldName(vulnerability.getId()), vulnerability.getDescription(), solrDocument);

            // Severity
            this.solrUtils.setAtomic(SolrUtils.ATOMIC_UPDATE_MODIFIER_SET, getSeverityFieldName(vulnerability.getId()),
                vulnerability.getSeverity(), solrDocument);
        }

        // Ids
        this.solrUtils.setAtomic(SolrUtils.ATOMIC_UPDATE_MODIFIER_SET, SOLR_FIELD_VULNERAVILITY_IDS, ids, solrDocument);

        this.extensionIndexClient.add(solrDocument);

        this.extensionIndexClient.commit();
    }

    /**
     * Search indexed extensions based of the provided query.
     * 
     * @param query the query
     * @return the found extensions descriptors, empty list if nothing could be found
     * @throws SearchException error when trying to search provided query
     */
    public IterableResult<FASTENExtension> search(FASTENExtensionQuery query) throws SearchException
    {
        SolrQuery solrQuery = new SolrQuery();

        createSolrQuery(query, solrQuery);

        // Execute the search
        QueryResponse response;
        try {
            response = this.store.search(solrQuery);
        } catch (Exception e) {
            throw new SearchException("Failed to search extension for query [" + query + "]", e);
        }

        SolrDocumentList documents = response.getResults();

        List<FASTENExtension> extensions = documents.stream().map(this::toSolrExtension).collect(Collectors.toList());

        return new CollectionIterableResult<>((int) documents.getNumFound(), (int) documents.getStart(), extensions);
    }

    private void createSolrQuery(FASTENExtensionQuery query, SolrQuery solrQuery)
    {
        // Standard query
        this.store.createSolrQuery(query, solrQuery);

        // FASTEN query
        // Return only extension with vulnerabilities
        solrQuery.addFilterQuery(SOLR_FIELD_VULNERAVILITY_IDS + ":[* TO *]");
    }

    private FASTENExtension toSolrExtension(SolrDocument document)
    {
        FASTENSolrExtension extension =
            new FASTENSolrExtension(this.installedExtension, this.store.getExtensionId(document));

        // Standard fields
        this.store.toSolrExtension(document, extension);

        // FASTEN fields
        Collection<String> vulneravilityIds = this.solrUtils.getCollection(Extension.FIELD_ALLOWEDNAMESPACES, document);
        if (vulneravilityIds != null) {
            for (String vulneravilityId : vulneravilityIds) {
                String description = this.solrUtils.get(getDescriptionFieldName(vulneravilityId), document);
                String severity = this.solrUtils.get(getSeverityFieldName(vulneravilityId), document);

                extension.addVulnerability(new FASTENVulnerability(vulneravilityId, description, severity));
            }
        }

        return extension;
    }
}
